1、细部：
	request login +1
	request port （废弃）
	request user info +1
	request gameinfo +1
	request serverinfo +1
	
	download game client 使用web方式下载，不再单独提供协议
	
	upload game info
	upload server info
NetworkData
	Information：时间戳系统
		UserInfo
		GameInfo
		ServerInfo
	Request

ClientInformationProcessor:
	c->s : EInformationProtocol head <data>
	s->c :
		EIP_DownloadRemoteMtime : head remoteMtime
		EIP_DownloadData : head localMtime data
		EIP_UploadData : head result

地瓜皮重构计划第三阶段详细方案草案
2011-11-10 21:43:25

计划：
1、在线控制。已登录者不能重复登录。
2、MainServer增加来自GameServer的LoginHashCode验证接口。
3、看来Snake不得不重构一下了。
4、用户注册功能、请求提权功能、注册游戏功能、注册服务器功能。

方案：
1、邮件系统可以基于已有的Information系统构建，
    JMain : public JSerializableData
        - JID m_sender;//需要服务器端验证
        - QList<JID> m_receiver;
        - QDataTime m_sendtime;//需要服务器端验证
        - QString m_content;
2、在《设计模式》中介绍过一个strategy的模式。邮件系统的服务器端验证使用strategy模式设计。并提供一个实现，只验证sender和sendtime。
+3、服务器端socket在调用processor前增加验证功能。同样使用strategy设计。strategy对象能够拿到socket对象以调用disconnectFromHost方法，并由返回值决定是否调用process方法。
+4、Information系统中增加JLoginUser以支持注册功能。
x5、将Information系统中的验证过程也用strategy重新实现。
.6、单独增加一个更改用户权限的接口。使用strategy设计。基本的实现为：一个管理员只能给一个向别比他低的用户赋予一个级别比他低的权限。
7、MainClient断线时弹出提出窗口。
+8、Command接口增加返回值。


感谢
推荐
喜欢
elephant liu
2011-11-11 14:21:01 elephant liu

4.1、不将JLoginUser加入到Information中从而简化Information系统及socket的processor验证过程。
> 删除
elephant liu
2011-11-11 14:25:23 elephant liu

邮件系统比我想象的要复杂得多。
1.1、考虑到“已读邮件”和“未读邮件”等问题，需要在Information系统中增加两个列表。
1.2、考虑到“收到新邮件”提醒功能，需要在Information系统的processor对象中添加一个Observer对象（《设计模式》）。
> 删除
elephant liu
2011-11-11 19:49:51 elephant liu

4.1.1、用户注册接口完成。明天把用户界面写出来就算完成了。

把JSession放到JSocketBase中？

waste code:
void JClientSocketBase::connectToServer(const SHost& host){
	if(m_socket->state()==QAbstractSocket::ConnectedState)
	{
		if(m_socket->peerAddress()==host.m_address&& m_socket->peerPort()==host.m_port)
		{
			return;
		}else{
			m_socket->disconnectFromHost();
		}
	}
	m_socket->connectToHost(host.m_address,host.m_port);
}

void JClientNetworkDataProcessorBase::setSocket(JClientSocketBase* socket)
{
	m_socket=socket;
}

JClientSocketBase* JClientNetworkDataProcessorBase::getSocket()const
{
	return m_socket;
}

JCode JClientNetworkDataProcessorBase::sendData(const QByteArray& data)
{
	return getSocket()->sendData(getProcessorType(),data);
}

void JServerNetworkDataProcessorBase::sendData(const QByteArray& data)
{
	m_socket->sendData(getProcessorType(),data);
}

JSession* JServerNetworkDataProcessorBase::getSession()const
{
	return m_session;
}
